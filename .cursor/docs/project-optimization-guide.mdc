---
description:
globs:
alwaysApply: false
---
# å¾®ä¿¡å°ç¨‹åºé¡¹ç›®é…ç½®ä¼˜åŒ–æŒ‡å—

> **ç‰ˆæœ¬**: 2025å¹´1æœˆæœ€æ–°ç‰ˆ
> **é€‚ç”¨èŒƒå›´**: å°ç¨‹åºé¡¹ç›®é…ç½®ã€æ€§èƒ½ä¼˜åŒ–ã€å¼€å‘æ•ˆç‡æå‡

## ğŸ“‹ ç›®å½•

- [é¡¹ç›®é…ç½®ä¼˜åŒ–](#é¡¹ç›®é…ç½®ä¼˜åŒ–)
- [æ€§èƒ½ä¼˜åŒ–ç­–ç•¥](#æ€§èƒ½ä¼˜åŒ–ç­–ç•¥)
- [å¼€å‘æ•ˆç‡æå‡](#å¼€å‘æ•ˆç‡æå‡)
- [ä»£ç è´¨é‡ä¿è¯](#ä»£ç è´¨é‡ä¿è¯)
- [éƒ¨ç½²å‘å¸ƒä¼˜åŒ–](#éƒ¨ç½²å‘å¸ƒä¼˜åŒ–)
- [ç›‘æ§ä¸åˆ†æ](#ç›‘æ§ä¸åˆ†æ)

---

## é¡¹ç›®é…ç½®ä¼˜åŒ–

### project.config.json ä¼˜åŒ–

```json
{
  "description": "é¡¹ç›®é…ç½®æ–‡ä»¶",
  "packOptions": {
    "ignore": [
      {
        "type": "file",
        "value": ".eslintrc.js"
      },
      {
        "type": "file",
        "value": ".gitignore"
      },
      {
        "type": "file",
        "value": "README.md"
      },
      {
        "type": "folder",
        "value": "docs"
      },
      {
        "type": "folder",
        "value": "test"
      }
    ]
  },
  "setting": {
    "urlCheck": true,
    "es6": true,
    "enhance": true,
    "postcss": true,
    "preloadBackgroundData": false,
    "minified": true,
    "newFeature": true,
    "coverView": true,
    "nodeModules": false,
    "autoAudits": true,
    "showShadowRootInWxmlPanel": true,
    "scopeDataCheck": false,
    "uglifyFileName": false,
    "checkInvalidKey": true,
    "checkSiteMap": true,
    "uploadWithSourceMap": true,
    "compileHotReLoad": false,
    "lazyloadPlaceholderEnable": false,
    "useMultiFrameRuntime": true,
    "useApiHook": true,
    "useApiHostProcess": true,
    "babelSetting": {
      "ignore": [],
      "disablePlugins": [],
      "outputPath": ""
    },
    "enableEngineNative": false,
    "useIsolateContext": false,
    "userConfirmedBundleSwitch": false,
    "packNpmManually": false,
    "packNpmRelationList": [],
    "minifyWXSS": true,
    "disableUseStrict": false,
    "minifyWXML": true,
    "showES6CompileOption": false,
    "useCompilerPlugins": false
  },
  "compileType": "miniprogram",
  "libVersion": "2.33.1",
  "appid": "your_app_id",
  "projectname": "miniprogram-demo",
  "condition": {
    "search": {
      "list": []
    },
    "conversation": {
      "list": []
    },
    "game": {
      "list": []
    },
    "plugin": {
      "list": []
    },
    "gamePlugin": {
      "list": []
    },
    "miniprogram": {
      "list": [
        {
          "name": "é¦–é¡µ",
          "pathName": "pages/index/index",
          "query": "",
          "scene": null
        },
        {
          "name": "ä¸ªäººä¸­å¿ƒ",
          "pathName": "pages/profile/profile",
          "query": "id=123",
          "scene": null
        }
      ]
    }
  }
}
```

### sitemap.json ä¼˜åŒ–

```json
{
  "desc": "å…³äºæœ¬æ–‡ä»¶çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚è€ƒæ–‡æ¡£ https://developers.weixin.qq.com/miniprogram/dev/framework/sitemap.html",
  "rules": [
    {
      "action": "allow",
      "page": "pages/index/index"
    },
    {
      "action": "allow",
      "page": "pages/article/detail",
      "params": ["id"]
    },
    {
      "action": "disallow",
      "page": "pages/profile/*"
    },
    {
      "action": "disallow",
      "page": "pages/admin/*"
    }
  ]
}
```

---

## æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. åˆ†åŒ…é…ç½®ä¼˜åŒ–

```json
{
  "pages": [
    "pages/index/index",
    "pages/search/search"
  ],
  "subpackages": [
    {
      "root": "packageA",
      "name": "user",
      "pages": [
        "pages/profile/profile",
        "pages/settings/settings"
      ]
    },
    {
      "root": "packageB",
      "name": "business",
      "pages": [
        "pages/order/list",
        "pages/order/detail"
      ]
    }
  ],
  "preloadRule": {
    "pages/index/index": {
      "network": "all",
      "packages": ["user"]
    }
  },
  "lazyCodeLoading": "requiredComponents"
}
```

### 2. å›¾ç‰‡èµ„æºä¼˜åŒ–

```javascript
// utils/image-optimizer.js
class ImageOptimizer {
  // å‹ç¼©å›¾ç‰‡
  static compressImage(src, quality = 0.8) {
    return new Promise((resolve, reject) => {
      const canvas = wx.createCanvasContext('compressCanvas');
      const img = canvas.createImage();

      img.onload = () => {
        const { width, height } = img;
        const ratio = Math.min(800 / width, 800 / height);
        const newWidth = width * ratio;
        const newHeight = height * ratio;

        canvas.drawImage(img, 0, 0, newWidth, newHeight);
        canvas.draw(false, () => {
          wx.canvasToTempFilePath({
            canvasId: 'compressCanvas',
            quality: quality,
            success: resolve,
            fail: reject
          });
        });
      };

      img.src = src;
    });
  }

  // ç”Ÿæˆç¼©ç•¥å›¾
  static generateThumbnail(src, size = 200) {
    return this.compressImage(src, 0.6).then(res => {
      // è¿›ä¸€æ­¥å¤„ç†ç¼©ç•¥å›¾
      return res.tempFilePath;
    });
  }

  // æ‡’åŠ è½½å›¾ç‰‡
  static lazyLoadImages(selector = '.lazy-image') {
    const observer = wx.createIntersectionObserver();

    observer.relativeToViewport().observe(selector, (res) => {
      if (res.intersectionRatio > 0) {
        const dataset = res.target.dataset;
        const realSrc = dataset.src;

        // åŠ è½½çœŸå®å›¾ç‰‡
        res.target.src = realSrc;
        observer.unobserve(res.target);
      }
    });

    return observer;
  }
}

module.exports = ImageOptimizer;
```

### 3. æ•°æ®ç¼“å­˜ä¼˜åŒ–

```javascript
// utils/cache-manager.js
class CacheManager {
  constructor() {
    this.memoryCache = new Map();
    this.maxMemorySize = 50; // å†…å­˜ç¼“å­˜æœ€å¤§æ¡æ•°
  }

  // å¤šçº§ç¼“å­˜ç­–ç•¥
  async get(key, fetcher, options = {}) {
    const {
      memoryTTL = 5 * 60 * 1000,  // å†…å­˜ç¼“å­˜5åˆ†é’Ÿ
      storageTTL = 30 * 60 * 1000, // æœ¬åœ°å­˜å‚¨30åˆ†é’Ÿ
      forceRefresh = false
    } = options;

    if (forceRefresh) {
      return this.fetchAndCache(key, fetcher, { memoryTTL, storageTTL });
    }

    // 1. æ£€æŸ¥å†…å­˜ç¼“å­˜
    const memoryData = this.getFromMemory(key);
    if (memoryData && !this.isExpired(memoryData, memoryTTL)) {
      return memoryData.data;
    }

    // 2. æ£€æŸ¥æœ¬åœ°å­˜å‚¨ç¼“å­˜
    const storageData = this.getFromStorage(key);
    if (storageData && !this.isExpired(storageData, storageTTL)) {
      // åŒæ­¥åˆ°å†…å­˜ç¼“å­˜
      this.setToMemory(key, storageData.data);
      return storageData.data;
    }

    // 3. ä»ç½‘ç»œè·å–
    return this.fetchAndCache(key, fetcher, { memoryTTL, storageTTL });
  }

  async fetchAndCache(key, fetcher, { memoryTTL, storageTTL }) {
    try {
      const data = await fetcher();

      // ç¼“å­˜åˆ°å†…å­˜å’Œæœ¬åœ°å­˜å‚¨
      this.setToMemory(key, data);
      this.setToStorage(key, data);

      return data;
    } catch (error) {
      console.error('è·å–æ•°æ®å¤±è´¥', error);

      // å°è¯•è¿”å›è¿‡æœŸçš„ç¼“å­˜æ•°æ®
      const fallbackData = this.getFromStorage(key);
      if (fallbackData) {
        return fallbackData.data;
      }

      throw error;
    }
  }

  getFromMemory(key) {
    return this.memoryCache.get(key);
  }

  setToMemory(key, data) {
    // LRU æ·˜æ±°ç­–ç•¥
    if (this.memoryCache.size >= this.maxMemorySize) {
      const firstKey = this.memoryCache.keys().next().value;
      this.memoryCache.delete(firstKey);
    }

    this.memoryCache.set(key, {
      data,
      timestamp: Date.now()
    });
  }

  getFromStorage(key) {
    try {
      const stored = wx.getStorageSync(`cache_${key}`);
      return stored ? JSON.parse(stored) : null;
    } catch (error) {
      return null;
    }
  }

  setToStorage(key, data) {
    try {
      wx.setStorageSync(`cache_${key}`, JSON.stringify({
        data,
        timestamp: Date.now()
      }));
    } catch (error) {
      console.error('ç¼“å­˜åˆ°æœ¬åœ°å­˜å‚¨å¤±è´¥', error);
    }
  }

  isExpired(cacheData, ttl) {
    return Date.now() - cacheData.timestamp > ttl;
  }

  clear(key) {
    if (key) {
      this.memoryCache.delete(key);
      wx.removeStorageSync(`cache_${key}`);
    } else {
      this.memoryCache.clear();
      // æ¸…é™¤æ‰€æœ‰ç¼“å­˜
      const info = wx.getStorageInfoSync();
      info.keys.forEach(k => {
        if (k.startsWith('cache_')) {
          wx.removeStorageSync(k);
        }
      });
    }
  }
}

module.exports = new CacheManager();
```

### 4. è¯·æ±‚ä¼˜åŒ–

```javascript
// utils/request-optimizer.js
class RequestOptimizer {
  constructor() {
    this.pendingRequests = new Map();
    this.requestQueue = [];
    this.maxConcurrent = 10;
    this.currentRequests = 0;
  }

  // è¯·æ±‚å»é‡
  async request(url, options = {}) {
    const key = this.generateKey(url, options);

    // å¦‚æœæœ‰ç›¸åŒçš„è¯·æ±‚æ­£åœ¨è¿›è¡Œï¼Œç›´æ¥è¿”å›Promise
    if (this.pendingRequests.has(key)) {
      return this.pendingRequests.get(key);
    }

    const promise = this.executeRequest(url, options);
    this.pendingRequests.set(key, promise);

    promise.finally(() => {
      this.pendingRequests.delete(key);
    });

    return promise;
  }

  // å¹¶å‘æ§åˆ¶
  async executeRequest(url, options) {
    return new Promise((resolve, reject) => {
      const task = { url, options, resolve, reject };

      if (this.currentRequests < this.maxConcurrent) {
        this.processRequest(task);
      } else {
        this.requestQueue.push(task);
      }
    });
  }

  async processRequest({ url, options, resolve, reject }) {
    this.currentRequests++;

    try {
      const result = await this.makeRequest(url, options);
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      this.currentRequests--;

      // å¤„ç†é˜Ÿåˆ—ä¸­çš„ä¸‹ä¸€ä¸ªè¯·æ±‚
      if (this.requestQueue.length > 0) {
        const nextTask = this.requestQueue.shift();
        this.processRequest(nextTask);
      }
    }
  }

  makeRequest(url, options) {
    return new Promise((resolve, reject) => {
      wx.request({
        url,
        ...options,
        success: (res) => {
          if (res.statusCode === 200) {
            resolve(res.data);
          } else {
            reject(new Error(`HTTP ${res.statusCode}`));
          }
        },
        fail: reject
      });
    });
  }

  generateKey(url, options) {
    return `${options.method || 'GET'}_${url}_${JSON.stringify(options.data || {})}`;
  }

  // æ‰¹é‡è¯·æ±‚
  async batchRequest(requests, options = {}) {
    const { batchSize = 5, delay = 100 } = options;
    const results = [];

    for (let i = 0; i < requests.length; i += batchSize) {
      const batch = requests.slice(i, i + batchSize);
      const batchPromises = batch.map(req => this.request(req.url, req.options));

      try {
        const batchResults = await Promise.all(batchPromises);
        results.push(...batchResults);

        // æ‰¹æ¬¡é—´å»¶è¿Ÿ
        if (i + batchSize < requests.length) {
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      } catch (error) {
        console.error('æ‰¹é‡è¯·æ±‚å¤±è´¥', error);
        throw error;
      }
    }

    return results;
  }
}

module.exports = new RequestOptimizer();
```

---

## å¼€å‘æ•ˆç‡æå‡

### 1. è‡ªåŠ¨åŒ–è„šæœ¬

```javascript
// scripts/auto-generate.js
const fs = require('fs');
const path = require('path');

class PageGenerator {
  static generate(pageName, options = {}) {
    const { hasTab = false, template = 'basic' } = options;
    const pagePath = path.join('pages', pageName);

    // åˆ›å»ºç›®å½•
    if (!fs.existsSync(pagePath)) {
      fs.mkdirSync(pagePath, { recursive: true });
    }

    // ç”Ÿæˆæ–‡ä»¶
    this.generateJS(pagePath, pageName, template);
    this.generateJSON(pagePath, pageName, hasTab);
    this.generateWXML(pagePath, pageName, template);
    this.generateWXSS(pagePath, pageName);

    console.log(`é¡µé¢ ${pageName} ç”Ÿæˆå®Œæˆï¼`);
  }

  static generateJS(pagePath, pageName, template) {
    let content = '';

    switch (template) {
      case 'list':
        content = this.getListTemplate(pageName);
        break;
      case 'detail':
        content = this.getDetailTemplate(pageName);
        break;
      default:
        content = this.getBasicTemplate(pageName);
    }

    fs.writeFileSync(path.join(pagePath, `${pageName}.js`), content);
  }

  static getBasicTemplate(pageName) {
    return `// pages/${pageName}/${pageName}.js
const app = getApp();

Page({
  data: {
    loading: false
  },

  onLoad(options) {
    console.log('${pageName} é¡µé¢åŠ è½½', options);
    this.initPage();
  },

  onReady() {
    console.log('${pageName} é¡µé¢æ¸²æŸ“å®Œæˆ');
  },

  onShow() {
    console.log('${pageName} é¡µé¢æ˜¾ç¤º');
  },

  onHide() {
    console.log('${pageName} é¡µé¢éšè—');
  },

  onUnload() {
    console.log('${pageName} é¡µé¢å¸è½½');
  },

  onPullDownRefresh() {
    this.refreshData();
  },

  onReachBottom() {
    console.log('è§¦åº•åŠ è½½æ›´å¤š');
  },

  onShareAppMessage() {
    return {
      title: '${pageName}é¡µé¢',
      path: '/pages/${pageName}/${pageName}'
    };
  },

  // åˆå§‹åŒ–é¡µé¢
  initPage() {
    this.loadData();
  },

  // åŠ è½½æ•°æ®
  async loadData() {
    this.setData({ loading: true });

    try {
      // TODO: å®ç°æ•°æ®åŠ è½½é€»è¾‘
      console.log('åŠ è½½æ•°æ®...');

      this.setData({ loading: false });
    } catch (error) {
      console.error('åŠ è½½æ•°æ®å¤±è´¥', error);
      this.setData({ loading: false });

      wx.showToast({
        title: 'åŠ è½½å¤±è´¥',
        icon: 'none'
      });
    }
  },

  // åˆ·æ–°æ•°æ®
  async refreshData() {
    try {
      await this.loadData();
      wx.showToast({
        title: 'åˆ·æ–°æˆåŠŸ',
        icon: 'success'
      });
    } catch (error) {
      wx.showToast({
        title: 'åˆ·æ–°å¤±è´¥',
        icon: 'none'
      });
    } finally {
      wx.stopPullDownRefresh();
    }
  }
});`;
  }

  static generateJSON(pagePath, pageName, hasTab) {
    const config = {
      navigationBarTitleText: `${pageName}é¡µé¢`,
      enablePullDownRefresh: true,
      onReachBottomDistance: 50,
      usingComponents: {}
    };

    if (hasTab) {
      delete config.enablePullDownRefresh;
    }

    fs.writeFileSync(
      path.join(pagePath, `${pageName}.json`),
      JSON.stringify(config, null, 2)
    );
  }

  static generateWXML(pagePath, pageName, template) {
    let content = '';

    switch (template) {
      case 'list':
        content = this.getListWXML(pageName);
        break;
      case 'detail':
        content = this.getDetailWXML(pageName);
        break;
      default:
        content = this.getBasicWXML(pageName);
    }

    fs.writeFileSync(path.join(pagePath, `${pageName}.wxml`), content);
  }

  static getBasicWXML(pageName) {
    return `<!--pages/${pageName}/${pageName}.wxml-->
<view class="container">
  <view class="header">
    <text class="title">${pageName}é¡µé¢</text>
  </view>

  <view class="content">
    <view wx:if="{{loading}}" class="loading">
      <text>åŠ è½½ä¸­...</text>
    </view>

    <view wx:else class="main-content">
      <!-- TODO: æ·»åŠ é¡µé¢å†…å®¹ -->
      <text>é¡µé¢å†…å®¹åŒºåŸŸ</text>
    </view>
  </view>
</view>`;
  }

  static generateWXSS(pagePath, pageName) {
    const content = `/* pages/${pageName}/${pageName}.wxss */
.container {
  min-height: 100vh;
  background: #f8f8f8;
}

.header {
  padding: 20rpx;
  background: #fff;
  border-bottom: 1rpx solid #eee;
}

.title {
  font-size: 36rpx;
  font-weight: 500;
  color: #333;
}

.content {
  flex: 1;
  padding: 20rpx;
}

.loading {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 200rpx;
  color: #666;
}

.main-content {
  background: #fff;
  border-radius: 12rpx;
  padding: 20rpx;
}`;

    fs.writeFileSync(path.join(pagePath, `${pageName}.wxss`), content);
  }
}

// ä½¿ç”¨ç¤ºä¾‹
// node scripts/auto-generate.js create-page user-profile --template=detail
module.exports = PageGenerator;
```

### 2. ç»„ä»¶åº“é…ç½®

```javascript
// config/components.js
module.exports = {
  // å…¨å±€ç»„ä»¶é…ç½®
  globalComponents: {
    // UIç»„ä»¶åº“
    'van-button': '@vant/weapp/button/index',
    'van-cell': '@vant/weapp/cell/index',
    'van-icon': '@vant/weapp/icon/index',
    'van-image': '@vant/weapp/image/index',
    'van-loading': '@vant/weapp/loading/index',
    'van-toast': '@vant/weapp/toast/index',
    'van-dialog': '@vant/weapp/dialog/index',

    // è‡ªå®šä¹‰ç»„ä»¶
    'custom-header': '/components/layout/header/index',
    'custom-footer': '/components/layout/footer/index',
    'loading-spinner': '/components/ui/loading/index',
    'error-boundary': '/components/ui/error-boundary/index'
  },

  // é¡µé¢çº§ç»„ä»¶é…ç½®
  pageComponents: {
    'user-card': '/components/business/user-card/index',
    'product-item': '/components/business/product-item/index',
    'order-card': '/components/business/order-card/index'
  }
};
```

---

## ä»£ç è´¨é‡ä¿è¯

### 1. ESLint é…ç½®

```javascript
// .eslintrc.js
module.exports = {
  env: {
    browser: true,
    es6: true,
    node: true
  },
  extends: [
    'eslint:recommended'
  ],
  globals: {
    wx: 'readonly',
    getApp: 'readonly',
    getCurrentPages: 'readonly',
    Page: 'readonly',
    Component: 'readonly',
    App: 'readonly'
  },
  parserOptions: {
    ecmaVersion: 2020,
    sourceType: 'module'
  },
  rules: {
    // ä»£ç é£æ ¼
    'indent': ['error', 2],
    'quotes': ['error', 'single'],
    'semi': ['error', 'always'],
    'comma-dangle': ['error', 'never'],

    // æœ€ä½³å®è·µ
    'no-console': 'warn',
    'no-unused-vars': 'error',
    'no-undef': 'error',
    'prefer-const': 'error',
    'no-var': 'error',

    // å°ç¨‹åºç‰¹å®šè§„åˆ™
    'no-global-assign': 'error',
    'no-implicit-globals': 'error'
  }
};
```

### 2. ä»£ç æ ¼å¼åŒ–é…ç½®

```json
// .prettierrc
{
  "printWidth": 100,
  "tabWidth": 2,
  "useTabs": false,
  "semi": true,
  "singleQuote": true,
  "quoteProps": "as-needed",
  "trailingComma": "none",
  "bracketSpacing": true,
  "arrowParens": "avoid",
  "endOfLine": "lf"
}
```

### 3. Git Hooks é…ç½®

```json
// package.json
{
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged",
      "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"
    }
  },
  "lint-staged": {
    "*.{js,wxs}": [
      "eslint --fix",
      "prettier --write",
      "git add"
    ],
    "*.{wxml,wxss}": [
      "prettier --write",
      "git add"
    ]
  }
}
```

---

## éƒ¨ç½²å‘å¸ƒä¼˜åŒ–

### 1. æ„å»ºä¼˜åŒ–

```javascript
// scripts/build.js
const fs = require('fs');
const path = require('path');
const { minify } = require('terser');

class BuildOptimizer {
  static async optimize() {
    console.log('å¼€å§‹æ„å»ºä¼˜åŒ–...');

    // 1. å‹ç¼©JSæ–‡ä»¶
    await this.minifyJS();

    // 2. å‹ç¼©WXSSæ–‡ä»¶
    await this.minifyWXSS();

    // 3. ä¼˜åŒ–å›¾ç‰‡èµ„æº
    await this.optimizeImages();

    // 4. ç”Ÿæˆæ„å»ºæŠ¥å‘Š
    await this.generateReport();

    console.log('æ„å»ºä¼˜åŒ–å®Œæˆï¼');
  }

  static async minifyJS() {
    const jsFiles = this.getFiles('.', /\.(js|wxs)$/);

    for (const file of jsFiles) {
      if (file.includes('node_modules')) continue;

      const code = fs.readFileSync(file, 'utf8');
      const result = await minify(code, {
        compress: {
          drop_console: true,
          drop_debugger: true
        },
        mangle: false // å°ç¨‹åºä¸å»ºè®®æ··æ·†
      });

      if (result.code) {
        fs.writeFileSync(file, result.code);
        console.log(`å‹ç¼©å®Œæˆ: ${file}`);
      }
    }
  }

  static async minifyWXSS() {
    const wxssFiles = this.getFiles('.', /\.wxss$/);

    for (const file of wxssFiles) {
      let content = fs.readFileSync(file, 'utf8');

      // ç®€å•çš„WXSSå‹ç¼©
      content = content
        .replace(/\/\*[\s\S]*?\*\//g, '') // ç§»é™¤æ³¨é‡Š
        .replace(/\s+/g, ' ') // å‹ç¼©ç©ºç™½
        .replace(/;\s*}/g, '}') // ç§»é™¤æœ€åçš„åˆ†å·
        .trim();

      fs.writeFileSync(file, content);
      console.log(`WXSSå‹ç¼©å®Œæˆ: ${file}`);
    }
  }

  static getFiles(dir, pattern) {
    const files = [];

    function traverse(currentDir) {
      const items = fs.readdirSync(currentDir);

      for (const item of items) {
        const fullPath = path.join(currentDir, item);
        const stat = fs.statSync(fullPath);

        if (stat.isDirectory()) {
          traverse(fullPath);
        } else if (pattern.test(item)) {
          files.push(fullPath);
        }
      }
    }

    traverse(dir);
    return files;
  }

  static async generateReport() {
    const report = {
      buildTime: new Date().toISOString(),
      fileCount: this.getFiles('.', /\.(js|wxml|wxss|json)$/).length,
      imageCount: this.getFiles('.', /\.(png|jpg|jpeg|gif|svg)$/).length,
      totalSize: this.calculateTotalSize()
    };

    fs.writeFileSync('build-report.json', JSON.stringify(report, null, 2));
    console.log('æ„å»ºæŠ¥å‘Šç”Ÿæˆå®Œæˆ:', report);
  }

  static calculateTotalSize() {
    const files = this.getFiles('.', /\.(js|wxml|wxss|json|png|jpg|jpeg|gif|svg)$/);
    let totalSize = 0;

    files.forEach(file => {
      const stat = fs.statSync(file);
      totalSize += stat.size;
    });

    return `${(totalSize / 1024 / 1024).toFixed(2)} MB`;
  }
}

module.exports = BuildOptimizer;
```

### 2. ç‰ˆæœ¬ç®¡ç†

```javascript
// scripts/version-manager.js
class VersionManager {
  static updateVersion(type = 'patch') {
    const packageJson = require('../package.json');
    const version = packageJson.version.split('.');

    switch (type) {
      case 'major':
        version[0] = String(Number(version[0]) + 1);
        version[1] = '0';
        version[2] = '0';
        break;
      case 'minor':
        version[1] = String(Number(version[1]) + 1);
        version[2] = '0';
        break;
      case 'patch':
      default:
        version[2] = String(Number(version[2]) + 1);
        break;
    }

    const newVersion = version.join('.');
    packageJson.version = newVersion;

    fs.writeFileSync('package.json', JSON.stringify(packageJson, null, 2));

    // æ›´æ–° app.json ä¸­çš„ç‰ˆæœ¬ä¿¡æ¯
    const appJson = require('../app.json');
    appJson.version = newVersion;
    fs.writeFileSync('app.json', JSON.stringify(appJson, null, 2));

    console.log(`ç‰ˆæœ¬æ›´æ–°ä¸º: ${newVersion}`);
    return newVersion;
  }

  static generateChangelog() {
    // ç”Ÿæˆæ›´æ–°æ—¥å¿—
    const changelog = `
## [${new Date().toISOString().split('T')[0]}] - ç‰ˆæœ¬æ›´æ–°

### æ–°å¢
- æ–°åŠŸèƒ½æè¿°

### ä¿®å¤
- Bugä¿®å¤æè¿°

### ä¼˜åŒ–
- æ€§èƒ½ä¼˜åŒ–æè¿°
`;

    fs.appendFileSync('CHANGELOG.md', changelog);
  }
}

module.exports = VersionManager;
```

---

## ç›‘æ§ä¸åˆ†æ

### 1. æ€§èƒ½ç›‘æ§

```javascript
// utils/performance-monitor.js
class PerformanceMonitor {
  constructor() {
    this.metrics = {
      pageLoadTime: {},
      apiResponseTime: {},
      memoryUsage: {},
      errors: []
    };
  }

  // é¡µé¢åŠ è½½æ—¶é—´ç›‘æ§
  startPageLoad(pageName) {
    this.metrics.pageLoadTime[pageName] = {
      startTime: Date.now()
    };
  }

  endPageLoad(pageName) {
    if (this.metrics.pageLoadTime[pageName]) {
      const loadTime = Date.now() - this.metrics.pageLoadTime[pageName].startTime;
      this.metrics.pageLoadTime[pageName].loadTime = loadTime;

      console.log(`é¡µé¢ ${pageName} åŠ è½½æ—¶é—´: ${loadTime}ms`);

      // ä¸ŠæŠ¥æ€§èƒ½æ•°æ®
      this.reportPerformance('pageLoad', {
        page: pageName,
        loadTime: loadTime
      });
    }
  }

  // APIå“åº”æ—¶é—´ç›‘æ§
  startApiCall(apiName) {
    this.metrics.apiResponseTime[apiName] = {
      startTime: Date.now()
    };
  }

  endApiCall(apiName, success = true) {
    if (this.metrics.apiResponseTime[apiName]) {
      const responseTime = Date.now() - this.metrics.apiResponseTime[apiName].startTime;
      this.metrics.apiResponseTime[apiName].responseTime = responseTime;
      this.metrics.apiResponseTime[apiName].success = success;

      console.log(`API ${apiName} å“åº”æ—¶é—´: ${responseTime}ms, æˆåŠŸ: ${success}`);

      // ä¸ŠæŠ¥APIæ€§èƒ½æ•°æ®
      this.reportPerformance('apiCall', {
        api: apiName,
        responseTime: responseTime,
        success: success
      });
    }
  }

  // å†…å­˜ä½¿ç”¨ç›‘æ§
  checkMemoryUsage() {
    if (wx.getPerformance) {
      const performance = wx.getPerformance();
      const memInfo = performance.getMemoryInfo();

      this.metrics.memoryUsage[Date.now()] = memInfo;

      // å†…å­˜ä½¿ç”¨è¿‡é«˜è­¦å‘Š
      if (memInfo.usedJSHeapSize > 50 * 1024 * 1024) { // 50MB
        console.warn('å†…å­˜ä½¿ç”¨è¿‡é«˜:', memInfo);
        this.reportPerformance('memoryWarning', memInfo);
      }
    }
  }

  // é”™è¯¯ç›‘æ§
  reportError(error, context) {
    const errorInfo = {
      message: error.message,
      stack: error.stack,
      context: context,
      timestamp: Date.now(),
      userAgent: wx.getSystemInfoSync()
    };

    this.metrics.errors.push(errorInfo);

    console.error('é”™è¯¯ä¸ŠæŠ¥:', errorInfo);

    // ä¸ŠæŠ¥é”™è¯¯ä¿¡æ¯
    this.reportPerformance('error', errorInfo);
  }

  // æ€§èƒ½æ•°æ®ä¸ŠæŠ¥
  reportPerformance(type, data) {
    // è¿™é‡Œå¯ä»¥é›†æˆç¬¬ä¸‰æ–¹ç›‘æ§æœåŠ¡
    // å¦‚ï¼šè…¾è®¯äº‘ç›‘æ§ã€é˜¿é‡Œäº‘ç›‘æ§ã€è‡ªå»ºç›‘æ§ç³»ç»Ÿç­‰

    wx.request({
      url: 'https://your-monitor-api.com/report',
      method: 'POST',
      data: {
        type: type,
        data: data,
        appId: wx.getAccountInfoSync().miniProgram.appId,
        timestamp: Date.now()
      },
      fail: (error) => {
        console.error('æ€§èƒ½æ•°æ®ä¸ŠæŠ¥å¤±è´¥:', error);
      }
    });
  }

  // è·å–æ€§èƒ½æŠ¥å‘Š
  getPerformanceReport() {
    return {
      ...this.metrics,
      reportTime: Date.now()
    };
  }
}

module.exports = new PerformanceMonitor();
```

### 2. ç”¨æˆ·è¡Œä¸ºåˆ†æ

```javascript
// utils/analytics.js
class Analytics {
  constructor() {
    this.sessionId = this.generateSessionId();
    this.userId = null;
    this.events = [];
  }

  // åˆå§‹åŒ–ç”¨æˆ·ID
  setUserId(userId) {
    this.userId = userId;
  }

  // é¡µé¢è®¿é—®ç»Ÿè®¡
  trackPageView(pageName, params = {}) {
    this.trackEvent('page_view', {
      page: pageName,
      params: params,
      timestamp: Date.now()
    });
  }

  // äº‹ä»¶ç»Ÿè®¡
  trackEvent(eventName, properties = {}) {
    const event = {
      eventName: eventName,
      properties: {
        ...properties,
        sessionId: this.sessionId,
        userId: this.userId,
        timestamp: Date.now(),
        systemInfo: wx.getSystemInfoSync()
      }
    };

    this.events.push(event);

    // æ‰¹é‡ä¸ŠæŠ¥äº‹ä»¶
    if (this.events.length >= 10) {
      this.flushEvents();
    }
  }

  // ç”¨æˆ·è¡Œä¸ºç»Ÿè®¡
  trackUserAction(action, target, extra = {}) {
    this.trackEvent('user_action', {
      action: action,
      target: target,
      ...extra
    });
  }

  // å•†ä¸šæŒ‡æ ‡ç»Ÿè®¡
  trackBusiness(metric, value, extra = {}) {
    this.trackEvent('business_metric', {
      metric: metric,
      value: value,
      ...extra
    });
  }

  // æ‰¹é‡ä¸ŠæŠ¥äº‹ä»¶
  flushEvents() {
    if (this.events.length === 0) return;

    const eventsToSend = [...this.events];
    this.events = [];

    wx.request({
      url: 'https://your-analytics-api.com/events',
      method: 'POST',
      data: {
        events: eventsToSend
      },
      success: () => {
        console.log(`ä¸ŠæŠ¥ ${eventsToSend.length} ä¸ªäº‹ä»¶æˆåŠŸ`);
      },
      fail: (error) => {
        console.error('äº‹ä»¶ä¸ŠæŠ¥å¤±è´¥:', error);
        // å¤±è´¥çš„äº‹ä»¶é‡æ–°åŠ å…¥é˜Ÿåˆ—
        this.events.unshift(...eventsToSend);
      }
    });
  }

  generateSessionId() {
    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}

module.exports = new Analytics();
```

---

## æ€»ç»“

é€šè¿‡ä»¥ä¸Šä¼˜åŒ–ç­–ç•¥ï¼Œå¯ä»¥æ˜¾è‘—æå‡å¾®ä¿¡å°ç¨‹åºçš„ï¼š

1. **æ€§èƒ½è¡¨ç°**: åˆ†åŒ…åŠ è½½ã€ç¼“å­˜ç­–ç•¥ã€è¯·æ±‚ä¼˜åŒ–
2. **å¼€å‘æ•ˆç‡**: è‡ªåŠ¨åŒ–è„šæœ¬ã€ç»„ä»¶åº“ã€ä»£ç ç”Ÿæˆ
3. **ä»£ç è´¨é‡**: ESLintã€Prettierã€Git Hooks
4. **å‘å¸ƒæµç¨‹**: æ„å»ºä¼˜åŒ–ã€ç‰ˆæœ¬ç®¡ç†ã€è‡ªåŠ¨åŒ–éƒ¨ç½²
5. **è¿è¥æ•°æ®**: æ€§èƒ½ç›‘æ§ã€ç”¨æˆ·è¡Œä¸ºåˆ†æã€é”™è¯¯ä¸ŠæŠ¥

è¿™äº›ä¼˜åŒ–æªæ–½èƒ½å¤Ÿå¸®åŠ©å¼€å‘å›¢é˜Ÿæ„å»ºæ›´åŠ ç¨³å®šã€é«˜æ•ˆã€å¯ç»´æŠ¤çš„å°ç¨‹åºåº”ç”¨ã€‚
